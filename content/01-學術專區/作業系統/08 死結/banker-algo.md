---
title: 銀行家演算法（Banker's Algorithm）
draft: false
tags:
  - operating-system
  - deadlock
date: 2025-12-10
---

**銀行家演算法**是一種死結避免（Deadlock Avoidance）演算法，由 Edsger Dijkstra 提出。它主要適用於每種資源類型具有多個實例（Multiple Instances）的系統環境 。

其名稱源自銀行的借貸運作模式：銀行在發放貸款前，必須確保在滿足該次貸款請求後，剩餘的資金仍足夠滿足所有客戶的最大潛在需求，以避免銀行破產（即死結）。

看得懂這張圖就可以跳過了
![[image-12.png]]

## 資料結構 (Data Structures)

假設系統中有 $n$ 個行程（Processes）與 $m$ 種資源類型（Resource Types）。為了實作演算法，需維護以下資料結構 ：

1.  **Available（可用資源向量）**：
    * 長度為 $m$ 的向量。
    * `Available[j] = k` 表示資源類型 $R_j$ 目前有 $k$ 個可用實例。
2.  **Max（最大需求矩陣）**：
    * $n \times m$ 的矩陣。
    * `Max[i,j] = k` 表示行程 $P_i$ 在執行過程中，對資源類型 $R_j$ 的最大需求量為 $k$。
3.  **Allocation（已分配矩陣）**：
    * $n \times m$ 的矩陣。
    * `Allocation[i,j] = k` 表示行程 $P_i$ 目前已持有 $k$ 個資源類型 $R_j$ 的實例。
4.  **Need（尚需資源矩陣）**：
    * $n \times m$ 的矩陣。
    * `Need[i,j] = k` 表示行程 $P_i$ 還需要 $k$ 個資源類型 $R_j$ 才能完成任務。
    * **關係式**：`Need[i,j] = Max[i,j] - Allocation[i,j]`。

## 演算法機制

銀行家演算法由兩個部分組成：**安全性演算法**用於判斷系統狀態是否安全，**資源請求演算法**用於決定是否批准請求。

### 安全性演算法 (Safety Algorithm)

此演算法用於判斷系統當前是否處於安全狀態（即是否存在安全序列）。

1.  **初始化**：
    * 令 `Work` 為長度 $m$ 的向量，`Finish` 為長度 $n$ 的向量。
    * 設定 `Work = Available`（複製目前可用資源）。
    * 設定 `Finish[i] = false` 對於所有 $i = 0, 1, ..., n-1$（標記所有行程尚未完成）。
2.  **尋找可執行行程**：
    * 尋找一個索引 $i$ 滿足以下兩條件：
        * `Finish[i] == false`（行程尚未完成）
        * `Need_i <= Work`（行程所需資源小於或等於目前可工作資源）
    * 若找不到這樣的 $i$，跳至步驟 4。
3.  **釋放資源**：
    * 假設行程 $P_i$ 獲得資源並執行完畢，釋放其持有的資源：
        * `Work = Work + Allocation_i`
        * `Finish[i] = true`
    * 跳回步驟 2。
4.  **判斷結果**：
    * 若所有 `Finish[i]` 皆為 `true`，則系統處於**安全狀態**。

### 資源請求演算法 (Resource-Request Algorithm)

當行程 $P_i$ 提出資源請求向量 `Request_i` 時，系統依以下步驟處理 ：

1.  **檢查需求上限**：
    * 若 `Request_i <= Need_i`，進入步驟 2。否則報錯（請求超過了宣告的最大需求）。
2.  **檢查可用資源**：
    * 若 `Request_i <= Available`，進入步驟 3。否則 $P_i$ 必須等待（資源不足）。
3.  **試探性分配 (Pretend Allocation)**：
    * 暫時修改系統狀態，假裝將資源分配給 $P_i$：
        * `Available = Available - Request_i`
        * `Allocation_i = Allocation_i + Request_i`
        * `Need_i = Need_i - Request_i`
4.  **執行安全性檢查**：
    * 呼叫 **安全性演算法** 檢查此新狀態是否安全。
    * **若安全**：正式分配資源給 $P_i$。
    * **若不安全**：還原上述狀態變更，$P_i$ 必須等待，直到資源足夠且分配後狀態安全為止。

## 實例推演

考慮系統有 5 個行程 ($P_0$ 到 $P_4$) 和 3 種資源類型 (A, B, C)。
資源總量：A(10), B(5), C(7)。

### 初始狀態 ($T_0$)

| 行程 | Allocation (已分配) | Max (最大需求) | Need (尚需) | Available (可用) |
| :--- | :--- | :--- | :--- | :--- |
| **$P_0$** | 0 1 0 | 7 5 3 | **7 4 3** | **3 3 2** |
| **$P_1$** | 2 0 0 | 3 2 2 | **1 2 2** | |
| **$P_2$** | 3 0 2 | 9 0 2 | **6 0 0** | |
| **$P_3$** | 2 1 1 | 2 2 2 | **0 1 1** | |
| **$P_4$** | 0 0 2 | 4 3 3 | **4 3 1** | |

**安全性檢查**：
系統處於**安全狀態**，因為存在安全序列 $<P_1, P_3, P_4, P_2, P_0>$ 。
* $P_1$ 需求 (1,2,2) $\le$ Available (3,3,2)。執行後釋放資源，Available 變為 (5,3,2)。
* $P_3$ 需求 (0,1,1) $\le$ Available (5,3,2)。執行後釋放資源，Available 變為 (7,4,3)。
* 依此類推，所有行程皆可完成。

### 資源請求實例

假設 **$P_1$ 請求 (1, 0, 2)** 。

1.  **檢查 1**：Request (1,0,2) $\le$ Need (1,2,2)。成立。
2.  **檢查 2**：Request (1,0,2) $\le$ Available (3,3,2)。成立。
3.  **試探性分配**：
    * `Available` 變為 $(3,3,2) - (1,0,2) = (2,3,0)$。
    * `Allocation_1` 變為 $(2,0,0) + (1,0,2) = (3,0,2)$。
    * `Need_1` 變為 $(1,2,2) - (1,0,2) = (0,2,0)$。
4.  **安全性檢查**：
    * 檢查新狀態下是否存在安全序列。
    * 計算發現序列 $<P_1, P_3, P_4, P_0, P_2>$ 仍可滿足所有需求 。
    * **結論**：請求被批准，資源正式分配。

[銀行家演算法模擬器](https://ai.studio/apps/drive/1dAt_7diOY0TEyNXs2RMDmAbDsUs2bKrT?fullscreenApplet=true)