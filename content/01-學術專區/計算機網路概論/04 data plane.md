---
title: 04 Data Plane
publish: false
tags:
  - computer-networks
date: 2025-12-06
---
> 當一個封包（Packet）到達路由器的入口時，路由器如何把它送到正確的出口？

- **Forwarding**: 當一個封包到達路由器的輸入端以後，路由器要決定將其移動到哪個輸出
- **Routing**: 決定封包的源頭到目的地的完整路徑

**Forwarding Table**
- **查表**：封包抵達後，路由器檢查封包的 Header，並以此當索引
- **轉送**：之後表會告訴路由器這個封包應該往哪個輸出介面送出去
- 這張表由 Control Plane 填的

> [!note] Transport Layer only provide Best-effort service.
> - **不保證**封包會送達（可能會掉包）。
> - **不保證**順序（可能會亂序）。
> - **不保證**時間（可能會延遲）。
> - **不保證**頻寬（可能會塞車）。

**Data Plane**
封包到達時，路由器決定要把它轉發到哪個鏈路。
超快（奈秒）
是當你開車經過台中交流道（路由器）時，看到路牌，決定「向右轉」進入匝道的那個瞬間動作 。
**控制平面 Control Plane**
網路範圍的邏輯，決定從源頭到目的的路徑要怎麼走。
很慢（秒級別）
是你在出發前用 Google Maps 規劃好「走國道一號轉台 78 線」的整體路徑。
## 路由器內有什麼？
- **輸入埠**：把光訊號轉成電訊號，並且查表（Lookup）
- **交換結構**：把封包從輸入搬到輸出
- **輸出埠**：把封包重新打包，排隊送出去
- **路由處理器**：這就是控制平面，透過路由協定計算出 Forwarding Table

## 如何查表
要非常快速，而且不可能 40 億個 IP 都一對一，所以用範圍來存。

網路層的標頭就是個 `struct`：
```c
struct IP_Header {
    // ... 其他欄位 (版本、長度、TTL...)
    uint32_t source_ip;      // 來源 IP
    uint32_t dest_ip;        // 目的端 IP
};
```
路由器只盯著 `dest_ip` 看，它可能會是 `11001000 ...`。

**Longest Prefix Matching Rule**
其實就是越具體越好的原則。想像你是路由器，你的 Forwarding Table 裡有這兩條規則（用二進位表示）：
- **規則 A (前 20 bits)**：`11001000 00010111 0001xxxx ...` -> 往出口 1 走
- **規則 B (前 24 bits)**：`11001000 00010111 00011000 ...` -> 往出口 2 走

這就像郵差送信：
- 規則 A 是送到「台北市」（範圍大，不精確）
- 規則 B 是送到「台北市信義區」（範圍小，更精確）

既然地址都寫了信義區，你當然要優先送給負責信義區的郵差。**規則 B 的「前綴」比較長（比對了 24 bits），表示它定義得更精確，所以路由器會選擇規則 B** 。
## DHCP
電腦確實內建了一組固定的編號，稱為 **MAC Address（媒體存取控制位址）**。這如同電腦的「身分證」，在出廠時即已設定完成（例如：00:1A:2B:3C:4D:5E）。相對地，**IP Address** 則類似於「座位號碼」或租屋處的地址，是裝置連上網路後由網路管理員所分配的。因此，MAC Address 是固定不變的識別名稱，而 IP Address 則是可變動的位置資訊。

針對「在不知道自身 IP 也不知伺服器 IP 的情況下如何連線」此一關鍵問題，解決方式如下：

1. 廣播機制（Broadcasting）：
    這是最原始的溝通方式。發送端將來源 IP 設定為 0.0.0.0（代表目前尚未取得 IP），並將目的 IP 設定為 255.255.255.255。此廣播封包會傳遍整個區域網路。
2. DHCP 伺服器的回應：
    雖然廣播訊息會傳送給區網內的所有裝置，但只有 DHCP 伺服器會進行回應，並協助分配 IP 給發送端。
3. **與 DNS 的區別**：
    - **DNS**：是在裝置「已經擁有 IP」後，用來查詢並尋找其他目標伺服器 IP 的服務。
    - **DHCP**：是用來協助裝置「找到自己 IP」的服務；若未完成此步驟，裝置將無法建立網路連線。
	
當 DHCP 伺服器接收到來自 `0.0.0.0` 的請求後，會回覆一個分配的 IP（例如 `192.168.1.10`）。由於此時客戶端尚未擁有有效的 IP 位址，伺服器會利用 MAC Address 來鎖定目標，並透過廣播的方式將訊息準確回傳。

這個互動過程即為 **DORA** 流程。針對多台伺服器的處理機制說明如下：
1. **Discover（發現）**：客戶端發送廣播，詢問哪台 DHCP 伺服器能提供 IP。
2. **Offer（提供）**：伺服器回應並提供一個 IP。
3. **Request（請求）與選擇**：若網路上有多台 DHCP 伺服器，客戶端可能會收到多個 Offer，此時需從中擇一。隨後，客戶端會發出 Request 封包，且依然採用「廣播」方式傳送。
4. **釋放資源**：使用廣播發送 Request 的目的，是為了同時告知其他未被選中的伺服器（例如 Server B）。當這些伺服器確認客戶端已選擇了別台伺服器後，便會將原本預留的 IP 位址收回並釋放，以供下一位使用者申請使用。
5. **Ack（Acknowledgement）：** Server A 收到你的請求後，會回傳一個 DHCP Ack，就正式把那個 IP Address 租給你了。

DHCP 分配的 IP 位址通常設有時效性（例如 8 小時）。為了確保連線穩定，客戶端必須在特定時間點（通常為租約過半，即 4 小時後）主動向 DHCP 伺服器發送請求（Request）進行續約，而伺服器通常皆會同意。

此機制不會等到連線實際中斷或租約完全過期後，才重新執行申請流程。系統運作採用了類似上下限（Lower Bound / Upper Bound）的預防性管理策略，旨在提前完成續約；若等到問題發生（租約過期）才採取行動，往往為時已晚。

> [!question] 數據機和路由器
> 許多人對於數據機（Modem）、路由器（Router）及分享器之間的差異感到困惑。儘管現代設備常將這些功能整合（例如分享器內建路由器功能），但在核心職責上，數據機與路由器有著明確的分工：
> 
> **1. 數據機（Modem）：訊號翻譯官**
> * **核心層級**：僅負責實體層（Physical Layer）與資料連結層（Data Link Layer），不處理網路層（Network Layer）的事務。
> * **主要功能**：作為訊號的「翻譯官」，負責將電話線或光纖傳輸的類比訊號，轉換為電腦可讀取的數位訊號。
> * **功能限制**：純粹的數據機不具備發放 IP、執行 NAT（網路位址轉換）或防火牆的功能。由於通常僅提供一個公有 IP，它無法直接支援多人同時上網。全世界駭客都可以直接掃描你電腦的端口。
> 
> **2. 路由器/分享器（Router）：網路管理者**
> * **核心層級**：專注於網路層，負責管理網路流量、路徑選擇及處理廣播風暴。
> * **整合功能**：現代的路由器（或無線分享器）功能強大，通常整合了以下機制：
>     * **NAT**：執行位址轉換。
>     * **DHCP Server**：自動分配 IP 位址。
>     * **防火牆**：提供網路安全防護。
>     * **無線基地台（Wireless AP）**：提供無線網路連接。
> 
> **總結**
> 兩者的工作界線相當清晰：數據機專注於底層的「訊號翻譯」；而路由器則負責其餘所有的「網路管理工作」，包含安全性維護、IP 分配及多裝置連線支援。

取得 IP 位址僅是建立連線的第一步，後續的封包傳輸還涉及更詳細的流程。除了 IP 位址外，DHCP 通常還會提供「預設閘道（Default Gateway，例如 192.168.1.1）」的資訊。由於網路區分為內網與外網，路由器作為關鍵樞紐，我們必須透過預設閘道才能將封包轉發至外部網路。

在傳輸過程中，系統必須先判斷目標是屬於「內網」還是「外網」，其判斷機制如下：

1. 子網路遮罩（Subnet Mask）與主機位（Host ID）：
    在同一個內網（由同一台路由器管理）中，所有裝置 IP 的前段部分皆相同，唯有最後一段的「主機位」不同（例如遮罩為 255.255.255.0）。
2. 邏輯運算（AND Operation）：
    系統會利用子網路遮罩進行「AND 運算」來識別網路位置：
    - 將「來源 IP（Client Source）」與「遮罩」進行 AND 運算。
    - 將「目標 IP（Destination IP）」與「遮罩」進行 AND 運算。
3. **判定結果與傳輸路徑：**
    - **若運算結果相同**：代表雙方僅主機位不同，處於同一個內網中，可直接傳輸。
    - **若運算結果不同**：代表目標位於外網。此時，系統會將封包發送給預設閘道。路由器接收後，會將封包重新打包（附上路由器自身的位址資訊），最終將其發送至網際網路。
## 交換結構
**記憶體交換**
- 用 CPU 讀進資料，然後 `memcpy` 到另一個 buffer。早期的路由器就是這樣，Input Port 發個中斷 (Interrupt) 給 CPU，CPU 把封包讀進記憶體，再寫到 Output Port。
- **缺點**：速度受限於記憶體頻寬 (Memory Bandwidth) 和 CPU 速度，一次只能搬一個封包。

**匯流排交換**
- 這就像是所有 Input Port 和 Output Port 共用一條系統匯流排 (Bus)。Input Port 直接把封包廣播到 Bus 上，只有對應的 Output Port 會把它收下來。
- **缺點**：匯流排一次只能通一台車。如果多個 Input Port 同時要送資料，其他人就得排隊 (Block)。

**縱橫式交換（Switching via Interconnection Network）**
- 這是最高級的。想像一個棋盤狀的開關矩陣。Input A 要去 Output 2，就把 (A, 2) 的交叉點接通。同時，Input B 要去 Output 3，就把 (B, 3) 接通。
- **優點**：可以**同時**傳送多個封包（只要它們不去同一個出口）！這就是現代高效能路由器的做法 。
### 額外設計
**佇列頭阻塞 HOL Blocking**
- 發生在 **輸入埠**。因為前面的人要去的地方塞車，害得要去不塞車地方的我也被卡住 。

**Output queuing**
- 發生在 **輸出埠**。因為大家都想去同一個地方，只好在出口排隊 。

**TTL**
- 為了避免死循環（A 丟給 B，B 又丟給 A），設定一個值，每經過一個路由器就減一，如果變成 0，那它就會被丟棄，並回傳 ICMP Time Exceeded 給發送端
- 地球上的網際網路直徑（跳數）通常不會超過 30 跳
> [!info] traceroute
> 我們常用的 `traceroute` 指令，就是故意發送 TTL=1, TTL=2, TTL=3... 的封包出去「送死」。當路由器因為 TTL=0 丟棄封包時，會回傳錯誤訊息，我們就能藉此知道路徑上有哪些路由器 。

**MTU（Maximum Transmission Unit）**
在網路上，每條連結 (Link) 能傳送的資料包大小是有上限的，這個上限叫做 **MTU (Maximum Transmission Unit)**。
- 乙太網路 (Ethernet) 的 MTU 通常是 **1,500 bytes** 。
- 但有些廣域網路 (WAN) 的連結可能更小（例如 576 bytes）。

**IP Fragmentation**
- 收到一個 4,000 bytes 的大封包，但它的下一個出口介面 (Output Link) 的 MTU 只有 1,500 bytes。因此必須把這個大封包「切碎」成好幾個小封包傳出去。
- Keep the network core simple
	1. **路由器很忙**：路由器的主要工作是「快速轉送」。如果要負責重組，它必須要停下來等所有碎片到齊（緩衝區 Buffer）、處理碎片遺失、計時等待...這會極大拖慢它的效能 。
	2. **不一定走同一條路**：網路是動態的。被切開的碎片 1 可能走路徑 A，碎片 2 可能走路徑 B。下一台路由器可能根本收不到所有的碎片，想組也組不起來。
	3. **端點最閒**：目的地主機（你的電腦）相對路由器來說資源很豐富，而且它一定要收到完整資料才能給應用程式，所以讓它在最後一關慢慢組最合適 。

> 所以，當你在用 Wi-Fi 看影片時，你的電腦（End System）其實正在默默地把你從網路上收到的一堆 IP 碎片重組回來，而中間經過的路由器完全不管這件事，它們只負責「切」，不負責「裝」。
## 封包排程演算法

## IP Address 結構
以前 IP 像是 `192.168.1.1`，這是點分十進位記法，這數字是有階層的。但這太死了，所以後來有了 CIDR（Classless Interdomain Routing），變成像是 `223.1.1.0/24`。

32 bits，前面 24 bits 是門牌，後面則是主機。
你也知道，$2^{24}$ 對比全球規模根本超級小。所以不是所有裝置都需要 Public IP，只需要推派一個代表（通常是你的無線路由器），讓它擁有唯一的一個全球 IP，其他人躲在它後面用「私有 IP (Private IP)」就好了。
### NAT
當你要上網時，路由器會幫你把你的「私有地址」轉換成它的「全球地址」送出去；回來時，再轉回來給你。這技術就稱作 **NAT (Network Address Translation)**。

NAT 其實是透過「借用」**Port (連接埠)** 來區分你是家裡的哪台電腦。
- 當你家裡的電腦 A 要連 Google，路由器會把它記在自己的 **Port 5001**。
- 電腦 B 也要連 Google，路由器會把它記在 **Port 5002**。
    
因為 Port 號碼是 16 位元 (bits)，理論上一個 Public IP 最多只能同時維持約 **60,000 個** 連線 。

### IPv6
直接把 32 bits 延伸到 128 bits。

> Ensure that the world won’t run out of IP addresses. Now, **every grain of sand on the planet can be IP-addressable**.

現在我們不需要路由器了，我們可以直接用階層式定址（Hierarchical Addressing）和子網路（Subnet）擔任束線帶的角色。

NAT 在運作時，路由器必須把封包拆開，修改 IP 表頭（把私有 IP 改成公有 IP），還要修改 Checksum，甚至要修改 Port 。這不只是束線帶，這比較像是把每一條電線剪斷、重新接頭，然後還要拿本筆記本記住哪條線原本是接哪裡的。

現在 IPv6 終於可以不違反網路設計的神聖原則：**端對端原則 (End-to-End Principle)** 了！它可以完全用**階層式 (Hierarchical)** 的方式來管理。
- **全球路由 (ISP)**：看前幾碼，把封包丟到你的國家/城市。
- **區域網路 (Site)**：看中間幾碼，丟到你的公司或學校。
- **子網路 (Subnet)**：看最後幾碼，丟到你的房間。

> [!question] 沒有 NAT，大家的 IP 都是公開的，那豈不是誰都能直接連進來駭我？
> 
> 這是很多人的誤解。**NAT 不是防火牆，它只是剛好有隱藏內部的副作用。** 在 IPv6 的世界裡，我們雖然拿掉了 NAT，但我們依然會在路由器（Router）上設置 **防火牆 (Firewall)**。
> - **IPv4 + NAT**：因為外面不知道你的 IP，所以連不進來（副作用）。
> - **IPv6**：外面知道你的 IP，但是被路由器擋在門口（正門警衛）。

總之 IPv6 既能保持網路整齊，又能讓兩台電腦在需要的時候（且被允許的時候）可以直接對話，不需要路由器在中間辛苦地「剪線重接」。